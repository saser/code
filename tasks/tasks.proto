syntax = "proto3";

package tasks;

import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

option go_package = "go.saser.se/tasks/tasks_go_proto";

service Tasks {
    // Get a single task by name.
    rpc GetTask(GetTaskRequest) returns (Task);

    // List tasks.
    rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);

    // Create a new task.
    rpc CreateTask(CreateTaskRequest) returns (Task);

    // Update a single task.
    rpc UpdateTask(UpdateTaskRequest) returns (Task);

    // Soft delete a task by name. Soft deleted tasks are still available for
    // some time but will eventually be permanently deleted.
    rpc DeleteTask(DeleteTaskRequest) returns (Task);

    // Undeletes a previously soft deleted task. Can only be done as long as the
    // task has not been permanently deleted.
    rpc UndeleteTask(UndeleteTaskRequest) returns (Task);
}

// A task is something that can be completed.
message Task {
    // The name of the task.
    // Format: tasks/{task}
    string name = 1;

    // The task under which this task is ordered. Optional. Used to build up a
    // hierarchy of tasks.
    // Format: tasks/{task}
    string parent = 2;

    // The title of the task. Must be a short string.
    string title = 3;

    // The description of the task. Can be a long string. Not all tasks have
    // descriptions.
    string description = 4;

    // Whether the task has been completed.
    bool completed = 5;

    // When the task was created.
    google.protobuf.Timestamp create_time = 6;

    // When the task was last soft deleted, if ever.
    google.protobuf.Timestamp delete_time = 7;

    // When the task will be permanently deleted after being soft deleted.
    google.protobuf.Timestamp expiry_time = 8;
}

message GetTaskRequest {
    // The name.
    // Format: tasks/{task}
    string name = 1;
}

message ListTasksRequest {
    // The standard page size. Optional. If unspecified, the server will choose
    // a suitable default. Values larger than 1000 will be truncated to 1000.
    int32 page_size = 1;

    // The standard page token. Optional. Get the values from responses to
    // ListTasks.
    string page_token = 2;

    // Whether soft deleted resources should be included in the response.
    bool show_deleted = 3;
}

message ListTasksResponse {
    // The tasks.
    repeated Task tasks = 1;

    // The token required to get the next page in a subsequent call to
    // ListTasks.
    string next_page_token = 2;
}

message CreateTaskRequest {
    // The task to be created. The `name` field will be ignored. The `title`
    // field must not be empty, and the `completed` field, if specified, must be
    // false.
    Task task = 1;
}

message UpdateTaskRequest {
    // The task to be updated. The `name` field is used to specify which task to
    // update. Only fields with non-default values will be updated, as long as
    // they are specified in `update_mask`.
    //
    // Note that trying to update the `completed` field is an error -- there are
    // separate RPCs for that.
    Task task = 1;

    // A field mask of which fields to update. A nil or empty field mask will be
    // interpreted as updating all fields specified in `task`. Specifying a
    // single `*` means doing a full replacement of the task.
    google.protobuf.FieldMask update_mask = 2;
}

message DeleteTaskRequest {
    // The name.
    // Format: tasks/{task}
    string name = 1;

    // Whether to force a cascading delete. If the named task has any child
    // tasks, and `force` is omitted or set to false, the deletion will fail. If
    // `force` is set to true, the named task will be deleted along with all
    // child tasks in a recursive fashion.
    bool force = 2;
}

message UndeleteTaskRequest {
    // The name.
    // Format: tasks/{task}
    string name = 1;

    // Whether to force a cascading undelete of ancestors. If the named task has
    // at least one deleted ancestor, and `undelete_ancestors` is omitted or set
    // to false, the undeletion will fail. If `undelete_ancestors` is set to
    // true, the named task will be undeleted along with all deleted ancestors,
    // direct or transitive.
    bool undelete_ancestors = 2;

    // Whether to also undelete any deleted descendant (direct or transitive)
    // tasks of the named task. Unlike `undelete_ancestors`, it is valid to omit
    // `undelete_descendants` or set it to false even if the named task has
    // deleted descendants.
    bool undelete_descendants = 3;
}
