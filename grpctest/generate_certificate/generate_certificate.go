// Command generate_certificate generates a X.509 certificate along with a
// private to be used in testing that requires an encrypted transport. The
// certificates and keys generated by this command *are not cryptographically
// secure* and should *never* be used in a production setting.
//
// This command is deterministic and hermetic -- given the same input flags, it
// will always output the same key and certificate files.
package main

// Much of this code is inspired by src/crypto/tls/generate_cert.go from the
// official Go distribution; specifically, this version:
// https://cs.opensource.google/go/go/+/master:src/crypto/tls/generate_cert.go;l=1;drc=2580d0e08d5e9f979b943758d3c49877fb2324cb

// Note that this program uses math/rand instead of crypto/rand.
// Cryptographically secure random number generation is not needed, but
// hermetic generation is -- this program is intended to be used in a Bazel
// `genrule`. Note also that this program uses ed25519 keys, instead of RSA.
// This is because even with a hermetic random number generation, there is code
// in place that prevents RSA key generation from being fully hermetic:
// https://cs.opensource.google/go/go/+/master:src/crypto/rsa/rsa.go;l=258;drc=0c4db1e347dc51589e5289388305b02108ca0aa1

import (
	"bytes"
	"crypto/ed25519"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"flag"
	"fmt"
	"io/fs"
	"math/big"
	"math/rand"
	"net"
	"os"
	"strings"
	"time"

	"github.com/golang/glog"
)

const dateLayout = "2006-01-02"

var (
	hostnamesFlag   = flag.String("hostnames", "", "Comma-separated list of hostnames to generate a certificate for. At least one of --hostnames and --ips must be given.")
	ipsFlag         = flag.String("ips", "", "Comma-separated list of IPs to generate a certificate for. At least one of --hostnames and --ips must be given.")
	notBeforeString = flag.String("not_before", "2022-01-01", "The date (format: YYYY-MM-DD) on which the certificate begins to be valid.")
	notAfterString  = flag.String("not_after", "2032-01-01", "The date (format: YYYY-MM-DD) on which the certificate ceases to be valid.")
	seed            = flag.Int64("seed", 1, "The seed to use for random number generation. The key and certificate generation is deterministic w.r.t. this seed.")

	keyOut  = flag.String("key_out", "", "Path to file where the PEM-encoded private key will be written.")
	certOut = flag.String("cert_out", "", "Path to file where the PEM-encoded certificate will be written.")
)

func errmain() error {
	if *hostnamesFlag == "" && *ipsFlag == "" {
		return errors.New("--hostnames and --ips are both empty; at least one is required")
	}
	hostnames := strings.Split(*hostnamesFlag, ",")
	for i, hostname := range hostnames {
		if hostname == "" {
			return fmt.Errorf("--hostnames=%q contains an empty hostname at index %d", *hostnamesFlag, i)
		}
	}
	var ips []net.IP
	for i, ipString := range strings.Split(*ipsFlag, ",") {
		ip := net.ParseIP(ipString)
		if ip == nil {
			return fmt.Errorf("--ips=%q contains an invalid IP %q at index %d", *ipsFlag, ipString, i)
		}
		ips = append(ips, ip)
	}
	notBefore, err := time.Parse(dateLayout, *notBeforeString)
	if err != nil {
		return fmt.Errorf("--not_before=%q is invalid: %w", *notBeforeString, err)
	}
	notAfter, err := time.Parse(dateLayout, *notAfterString)
	if err != nil {
		return fmt.Errorf("--not_after=%q is invalid: %w", *notAfterString, err)
	}
	if notBefore.After(notAfter) {
		return fmt.Errorf("--not_before=%q must be before --not_after=%q", *notBeforeString, *notAfterString)
	}
	if *keyOut == "" {
		return fmt.Errorf("--key_out is empty")
	}
	if *certOut == "" {
		return fmt.Errorf("--cert_out is empty")
	}

	// Generate and encode a key.
	publicKey, privateKey, err := ed25519.GenerateKey(rand.New(rand.NewSource(*seed)))
	if err != nil {
		return fmt.Errorf("failed to generate ed25519 key: %w", err)
	}
	privateKeyBytes, err := x509.MarshalPKCS8PrivateKey(privateKey)
	if err != nil {
		return fmt.Errorf("failed to marshal private key: %w", err)
	}
	var privateKeyPEMBytes bytes.Buffer
	if err := pem.Encode(&privateKeyPEMBytes, &pem.Block{
		Type:  "PRIVATE KEY",
		Bytes: privateKeyBytes,
	}); err != nil {
		return fmt.Errorf("failed to PEM-encode private key: %v", err)
	}

	// Generate and encode a certificate.
	template := &x509.Certificate{
		SerialNumber: new(big.Int).SetInt64(123),
		Subject: pkix.Name{
			Organization:       []string{"saser.se"},
			OrganizationalUnit: []string{"grpctest"},
		},
		DNSNames:              hostnames,
		IPAddresses:           ips,
		NotBefore:             notBefore,
		NotAfter:              notAfter,
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}
	certBytes, err := x509.CreateCertificate(rand.New(rand.NewSource(*seed)), template, template, publicKey, privateKey)
	if err != nil {
		return fmt.Errorf("failed to generate X.509 certificate: %w", err)
	}
	var certPEMBytes bytes.Buffer
	if err := pem.Encode(&certPEMBytes, &pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certBytes,
	}); err != nil {
		return fmt.Errorf("failed to PEM-encode certificate: %w", err)
	}

	// Now that we have everything encoded and ready we write it out to files.
	if err := os.WriteFile(*keyOut, privateKeyPEMBytes.Bytes(), fs.FileMode(0o777)); err != nil {
		return fmt.Errorf("failed to write private key to file: %w", err)
	}
	if err := os.WriteFile(*certOut, certPEMBytes.Bytes(), fs.FileMode(0o777)); err != nil {
		return fmt.Errorf("failed to write certificate to file: %w", err)
	}

	return nil
}

func main() {
	flag.Parse()
	if err := errmain(); err != nil {
		glog.Exit(err)
	}
}
